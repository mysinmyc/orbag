/* tslint:disable */
/* eslint-disable */
/**
 * orbag API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0-alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BindViewRequest
 */
export interface BindViewRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof BindViewRequest
     */
    'targetCi'?: ConfigurationItemReference;
    /**
     * 
     * @type {SerializableView}
     * @memberof BindViewRequest
     */
    'view'?: SerializableView;
}
/**
 * 
 * @export
 * @interface BindViewResponse
 */
export interface BindViewResponse {
    /**
     * 
     * @type {SerializableTable}
     * @memberof BindViewResponse
     */
    'resultTable'?: SerializableTable;
}
/**
 * 
 * @export
 * @interface BooleanField
 */
export interface BooleanField {
    /**
     * 
     * @type {string}
     * @memberof BooleanField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BooleanField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof BooleanField
     */
    'category'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanField
     */
    'value'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanField
     */
    'changed'?: boolean;
}
/**
 * 
 * @export
 * @interface BuildActionTemplateRequest
 */
export interface BuildActionTemplateRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof BuildActionTemplateRequest
     */
    'sourceCi'?: ConfigurationItemReference;
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof BuildActionTemplateRequest
     */
    'targetCis'?: Array<ConfigurationItemReference>;
    /**
     * 
     * @type {SerializableAction}
     * @memberof BuildActionTemplateRequest
     */
    'action'?: SerializableAction;
}
/**
 * 
 * @export
 * @interface ConfigResponse
 */
export interface ConfigResponse {
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    'applicationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    'loginMessage'?: string;
}
/**
 * 
 * @export
 * @interface ConfigurationItemReference
 */
export interface ConfigurationItemReference {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReference
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReference
     */
    'configurationItemType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReference
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReference
     */
    'configurationItemTypeDisplayLabel'?: string;
}
/**
 * 
 * @export
 * @interface ConfigurationItemReferenceField
 */
export interface ConfigurationItemReferenceField {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceField
     */
    'category'?: string;
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof ConfigurationItemReferenceField
     */
    'value'?: ConfigurationItemReference;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationItemReferenceField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationItemReferenceField
     */
    'changed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceField
     */
    'configurationItemType'?: string;
}
/**
 * 
 * @export
 * @interface ConfigurationItemReferenceListField
 */
export interface ConfigurationItemReferenceListField {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceListField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceListField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceListField
     */
    'category'?: string;
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof ConfigurationItemReferenceListField
     */
    'value'?: Array<ConfigurationItemReference>;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationItemReferenceListField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationItemReferenceListField
     */
    'changed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationItemReferenceListField
     */
    'configurationItemType'?: string;
}
/**
 * 
 * @export
 * @interface CreateRequest
 */
export interface CreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRequest
     */
    'configurationItemType'?: string;
    /**
     * 
     * @type {SerializableFieldGroup}
     * @memberof CreateRequest
     */
    'parameters'?: SerializableFieldGroup;
}
/**
 * 
 * @export
 * @interface CreateResponse
 */
export interface CreateResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateResponse
     */
    'executionStatus'?: CreateResponseExecutionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateResponse
     */
    'errorMessage'?: string;
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof CreateResponse
     */
    'validationErrors'?: Array<ValidationError>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateResponse
     */
    'requestValid'?: boolean;
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof CreateResponse
     */
    'configurationItem'?: ConfigurationItemReference;
}

export const CreateResponseExecutionStatusEnum = {
    ValidationFailed: 'VALIDATION_FAILED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED'
} as const;

export type CreateResponseExecutionStatusEnum = typeof CreateResponseExecutionStatusEnum[keyof typeof CreateResponseExecutionStatusEnum];

/**
 * 
 * @export
 * @interface EnumField
 */
export interface EnumField {
    /**
     * 
     * @type {string}
     * @memberof EnumField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnumField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnumField
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnumField
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnumField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnumField
     */
    'changed'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnumField
     */
    'allowedValues'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorPayload
 */
export interface ErrorPayload {
    /**
     * 
     * @type {number}
     * @memberof ErrorPayload
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorPayload
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface GenerateGraphRequest
 */
export interface GenerateGraphRequest {
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof GenerateGraphRequest
     */
    'rootCis'?: Array<ConfigurationItemReference>;
    /**
     * 
     * @type {SerializablePath}
     * @memberof GenerateGraphRequest
     */
    'path'?: SerializablePath;
}
/**
 * 
 * @export
 * @interface GenerateGraphResponse
 */
export interface GenerateGraphResponse {
    /**
     * 
     * @type {SerializableGraph}
     * @memberof GenerateGraphResponse
     */
    'graph'?: SerializableGraph;
}
/**
 * 
 * @export
 * @interface GetAvailableActionsRequest
 */
export interface GetAvailableActionsRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof GetAvailableActionsRequest
     */
    'sourceCi'?: ConfigurationItemReference;
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof GetAvailableActionsRequest
     */
    'targetCis'?: Array<ConfigurationItemReference>;
}
/**
 * 
 * @export
 * @interface GetAvailableActionsResponse
 */
export interface GetAvailableActionsResponse {
    /**
     * 
     * @type {Array<SerializableAction>}
     * @memberof GetAvailableActionsResponse
     */
    'availableActions'?: Array<SerializableAction>;
}
/**
 * 
 * @export
 * @interface GetAvailablePathsRequest
 */
export interface GetAvailablePathsRequest {
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof GetAvailablePathsRequest
     */
    'rootCis'?: Array<ConfigurationItemReference>;
}
/**
 * 
 * @export
 * @interface GetAvailablePathsResponse
 */
export interface GetAvailablePathsResponse {
    /**
     * 
     * @type {Array<SerializablePath>}
     * @memberof GetAvailablePathsResponse
     */
    'availablePaths'?: Array<SerializablePath>;
}
/**
 * 
 * @export
 * @interface GetAvailableViewsRequest
 */
export interface GetAvailableViewsRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof GetAvailableViewsRequest
     */
    'targetCi'?: ConfigurationItemReference;
}
/**
 * 
 * @export
 * @interface GetAvailableViewsResponse
 */
export interface GetAvailableViewsResponse {
    /**
     * 
     * @type {Array<SerializableView>}
     * @memberof GetAvailableViewsResponse
     */
    'availableViews'?: Array<SerializableView>;
}
/**
 * 
 * @export
 * @interface GetClassModelResponse
 */
export interface GetClassModelResponse {
    /**
     * 
     * @type {Array<SerializableConfigurationItemDescriptor>}
     * @memberof GetClassModelResponse
     */
    'configurationItemDescriptors'?: Array<SerializableConfigurationItemDescriptor>;
}
/**
 * 
 * @export
 * @interface ListConfigurationItemResponse
 */
export interface ListConfigurationItemResponse {
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof ListConfigurationItemResponse
     */
    'cis'?: Array<ConfigurationItemReference>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginRequest
     */
    'persistent'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'username'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginResponse
     */
    'authorities'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NumericField
 */
export interface NumericField {
    /**
     * 
     * @type {string}
     * @memberof NumericField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NumericField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof NumericField
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof NumericField
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NumericField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericField
     */
    'changed'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'configurationItemName'?: string;
    /**
     * 
     * @type {SerializableFieldGroup}
     * @memberof SearchRequest
     */
    'parameters'?: SerializableFieldGroup;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'resultType'?: SearchRequestResultTypeEnum;
}

export const SearchRequestResultTypeEnum = {
    RowReference: 'ROW_REFERENCE',
    HighlightedFields: 'HIGHLIGHTED_FIELDS',
    AllFields: 'ALL_FIELDS'
} as const;

export type SearchRequestResultTypeEnum = typeof SearchRequestResultTypeEnum[keyof typeof SearchRequestResultTypeEnum];

/**
 * 
 * @export
 * @interface SerializableAction
 */
export interface SerializableAction {
    /**
     * 
     * @type {string}
     * @memberof SerializableAction
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableAction
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableAction
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableAction
     */
    'quick'?: boolean;
}
/**
 * 
 * @export
 * @interface SerializableColumn
 */
export interface SerializableColumn {
    /**
     * 
     * @type {string}
     * @memberof SerializableColumn
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableColumn
     */
    'type'?: SerializableColumnTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SerializableColumn
     */
    'displayLabel'?: string;
}

export const SerializableColumnTypeEnum = {
    Primitive: 'Primitive',
    Reference: 'Reference'
} as const;

export type SerializableColumnTypeEnum = typeof SerializableColumnTypeEnum[keyof typeof SerializableColumnTypeEnum];

/**
 * 
 * @export
 * @interface SerializableConfigurationItemDescriptor
 */
export interface SerializableConfigurationItemDescriptor {
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'category'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'allowCreation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {Array<SerializableConfigurationItemPropertyDescriptor>}
     * @memberof SerializableConfigurationItemDescriptor
     */
    'properties'?: Array<SerializableConfigurationItemPropertyDescriptor>;
}
/**
 * 
 * @export
 * @interface SerializableConfigurationItemPropertyDescriptor
 */
export interface SerializableConfigurationItemPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'category'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'configurationItemReference'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'collection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SerializableConfigurationItemPropertyDescriptor
     */
    'referencedConfigurationItemType'?: string;
}
/**
 * 
 * @export
 * @interface SerializableFieldGroup
 */
export interface SerializableFieldGroup {
    /**
     * 
     * @type {Array<BooleanField>}
     * @memberof SerializableFieldGroup
     */
    'booleanFields'?: Array<BooleanField>;
    /**
     * 
     * @type {Array<ConfigurationItemReferenceField>}
     * @memberof SerializableFieldGroup
     */
    'configurationItemReferenceFields'?: Array<ConfigurationItemReferenceField>;
    /**
     * 
     * @type {Array<EnumField>}
     * @memberof SerializableFieldGroup
     */
    'enumFields'?: Array<EnumField>;
    /**
     * 
     * @type {Array<NumericField>}
     * @memberof SerializableFieldGroup
     */
    'numericFields'?: Array<NumericField>;
    /**
     * 
     * @type {Array<StringField>}
     * @memberof SerializableFieldGroup
     */
    'stringFields'?: Array<StringField>;
    /**
     * 
     * @type {Array<ConfigurationItemReferenceListField>}
     * @memberof SerializableFieldGroup
     */
    'configurationItemReferenceListFields'?: Array<ConfigurationItemReferenceListField>;
}
/**
 * 
 * @export
 * @interface SerializableGraph
 */
export interface SerializableGraph {
    /**
     * 
     * @type {Array<SerializableRelation>}
     * @memberof SerializableGraph
     */
    'relations'?: Array<SerializableRelation>;
}
/**
 * 
 * @export
 * @interface SerializablePath
 */
export interface SerializablePath {
    /**
     * 
     * @type {string}
     * @memberof SerializablePath
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializablePath
     */
    'displayLabel'?: string;
}
/**
 * 
 * @export
 * @interface SerializableRelation
 */
export interface SerializableRelation {
    /**
     * 
     * @type {string}
     * @memberof SerializableRelation
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableRelation
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof SerializableRelation
     */
    'startingCi'?: ConfigurationItemReference;
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof SerializableRelation
     */
    'endCi'?: ConfigurationItemReference;
}
/**
 * 
 * @export
 * @interface SerializableRow
 */
export interface SerializableRow {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SerializableRow
     */
    'fields'?: { [key: string]: object; };
    /**
     * 
     * @type {Set<string>}
     * @memberof SerializableRow
     */
    'tags'?: Set<string>;
}
/**
 * 
 * @export
 * @interface SerializableTable
 */
export interface SerializableTable {
    /**
     * 
     * @type {Array<SerializableColumn>}
     * @memberof SerializableTable
     */
    'columns'?: Array<SerializableColumn>;
    /**
     * 
     * @type {Array<SerializableRow>}
     * @memberof SerializableTable
     */
    'rows'?: Array<SerializableRow>;
}
/**
 * 
 * @export
 * @interface SerializableView
 */
export interface SerializableView {
    /**
     * 
     * @type {string}
     * @memberof SerializableView
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializableView
     */
    'displayLabel'?: string;
}
/**
 * 
 * @export
 * @interface StringField
 */
export interface StringField {
    /**
     * 
     * @type {string}
     * @memberof StringField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringField
     */
    'displayLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringField
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringField
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StringField
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StringField
     */
    'changed'?: boolean;
}
/**
 * 
 * @export
 * @interface SubmitActionRequest
 */
export interface SubmitActionRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof SubmitActionRequest
     */
    'sourceCi'?: ConfigurationItemReference;
    /**
     * 
     * @type {Array<ConfigurationItemReference>}
     * @memberof SubmitActionRequest
     */
    'targetCis'?: Array<ConfigurationItemReference>;
    /**
     * 
     * @type {SerializableAction}
     * @memberof SubmitActionRequest
     */
    'action'?: SerializableAction;
    /**
     * 
     * @type {SerializableFieldGroup}
     * @memberof SubmitActionRequest
     */
    'parameters'?: SerializableFieldGroup;
}
/**
 * 
 * @export
 * @interface SubmitActionResponse
 */
export interface SubmitActionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'executionStatus'?: SubmitActionResponseExecutionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'errorMessage'?: string;
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof SubmitActionResponse
     */
    'validationErrors'?: Array<ValidationError>;
    /**
     * 
     * @type {boolean}
     * @memberof SubmitActionResponse
     */
    'requestValid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'consequences'?: SubmitActionResponseConsequencesEnum;
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmitActionResponse
     */
    'jobId'?: string;
}

export const SubmitActionResponseExecutionStatusEnum = {
    ValidationFailed: 'VALIDATION_FAILED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED'
} as const;

export type SubmitActionResponseExecutionStatusEnum = typeof SubmitActionResponseExecutionStatusEnum[keyof typeof SubmitActionResponseExecutionStatusEnum];
export const SubmitActionResponseConsequencesEnum = {
    None: 'NONE',
    Undefined: 'UNDEFINED',
    Deleted: 'DELETED',
    Updated: 'UPDATED'
} as const;

export type SubmitActionResponseConsequencesEnum = typeof SubmitActionResponseConsequencesEnum[keyof typeof SubmitActionResponseConsequencesEnum];

/**
 * 
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
    /**
     * 
     * @type {ConfigurationItemReference}
     * @memberof UpdateRequest
     */
    'configurationItem'?: ConfigurationItemReference;
    /**
     * 
     * @type {SerializableFieldGroup}
     * @memberof UpdateRequest
     */
    'properties'?: SerializableFieldGroup;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface WhoAmIResponse
 */
export interface WhoAmIResponse {
    /**
     * 
     * @type {string}
     * @memberof WhoAmIResponse
     */
    'userName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WhoAmIResponse
     */
    'authorities'?: Array<string>;
}

/**
 * ActionControllerApi - axios parameter creator
 * @export
 */
export const ActionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build the request template to execute specified action
         * @summary Build action template
         * @param {BuildActionTemplateRequest} buildActionTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildExecutionTemplate: async (buildActionTemplateRequest: BuildActionTemplateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildActionTemplateRequest' is not null or undefined
            assertParamExists('buildExecutionTemplate', 'buildActionTemplateRequest', buildActionTemplateRequest)
            const localVarPath = `/api/action/buildExecutionTemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildActionTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return list of actions that user can executed on specified CIs
         * @summary Build available actions list
         * @param {GetAvailableActionsRequest} getAvailableActionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailable: async (getAvailableActionsRequest: GetAvailableActionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAvailableActionsRequest' is not null or undefined
            assertParamExists('getAvailable', 'getAvailableActionsRequest', getAvailableActionsRequest)
            const localVarPath = `/api/action/getAvailable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAvailableActionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit the action
         * @param {SubmitActionRequest} submitActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit: async (submitActionRequest: SubmitActionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitActionRequest' is not null or undefined
            assertParamExists('submit', 'submitActionRequest', submitActionRequest)
            const localVarPath = `/api/action/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionControllerApi - functional programming interface
 * @export
 */
export const ActionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Build the request template to execute specified action
         * @summary Build action template
         * @param {BuildActionTemplateRequest} buildActionTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildExecutionTemplate(buildActionTemplateRequest: BuildActionTemplateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitActionRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildExecutionTemplate(buildActionTemplateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return list of actions that user can executed on specified CIs
         * @summary Build available actions list
         * @param {GetAvailableActionsRequest} getAvailableActionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailable(getAvailableActionsRequest: GetAvailableActionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailableActionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailable(getAvailableActionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit the action
         * @param {SubmitActionRequest} submitActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submit(submitActionRequest: SubmitActionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submit(submitActionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionControllerApi - factory interface
 * @export
 */
export const ActionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionControllerApiFp(configuration)
    return {
        /**
         * Build the request template to execute specified action
         * @summary Build action template
         * @param {BuildActionTemplateRequest} buildActionTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildExecutionTemplate(buildActionTemplateRequest: BuildActionTemplateRequest, options?: any): AxiosPromise<SubmitActionRequest> {
            return localVarFp.buildExecutionTemplate(buildActionTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Return list of actions that user can executed on specified CIs
         * @summary Build available actions list
         * @param {GetAvailableActionsRequest} getAvailableActionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailable(getAvailableActionsRequest: GetAvailableActionsRequest, options?: any): AxiosPromise<GetAvailableActionsResponse> {
            return localVarFp.getAvailable(getAvailableActionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit the action
         * @param {SubmitActionRequest} submitActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(submitActionRequest: SubmitActionRequest, options?: any): AxiosPromise<SubmitActionResponse> {
            return localVarFp.submit(submitActionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionControllerApi - object-oriented interface
 * @export
 * @class ActionControllerApi
 * @extends {BaseAPI}
 */
export class ActionControllerApi extends BaseAPI {
    /**
     * Build the request template to execute specified action
     * @summary Build action template
     * @param {BuildActionTemplateRequest} buildActionTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionControllerApi
     */
    public buildExecutionTemplate(buildActionTemplateRequest: BuildActionTemplateRequest, options?: AxiosRequestConfig) {
        return ActionControllerApiFp(this.configuration).buildExecutionTemplate(buildActionTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return list of actions that user can executed on specified CIs
     * @summary Build available actions list
     * @param {GetAvailableActionsRequest} getAvailableActionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionControllerApi
     */
    public getAvailable(getAvailableActionsRequest: GetAvailableActionsRequest, options?: AxiosRequestConfig) {
        return ActionControllerApiFp(this.configuration).getAvailable(getAvailableActionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit the action
     * @param {SubmitActionRequest} submitActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionControllerApi
     */
    public submit(submitActionRequest: SubmitActionRequest, options?: AxiosRequestConfig) {
        return ActionControllerApiFp(this.configuration).submit(submitActionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationControllerApi - axios parameter creator
 * @export
 */
export const AuthenticationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Try to login the user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/authentication/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/authentication/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationControllerApi - functional programming interface
 * @export
 */
export const AuthenticationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Try to login the user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoAmI(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhoAmIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoAmI(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationControllerApi - factory interface
 * @export
 */
export const AuthenticationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationControllerApiFp(configuration)
    return {
        /**
         * Try to login the user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Return authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(options?: any): AxiosPromise<WhoAmIResponse> {
            return localVarFp.whoAmI(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationControllerApi - object-oriented interface
 * @export
 * @class AuthenticationControllerApi
 * @extends {BaseAPI}
 */
export class AuthenticationControllerApi extends BaseAPI {
    /**
     * Try to login the user
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationControllerApi
     */
    public login(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationControllerApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationControllerApi
     */
    public whoAmI(options?: AxiosRequestConfig) {
        return AuthenticationControllerApiFp(this.configuration).whoAmI(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigControllerApi - axios parameter creator
 * @export
 */
export const ConfigControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get application configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/config.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigControllerApi - functional programming interface
 * @export
 */
export const ConfigControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get application configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigControllerApi - factory interface
 * @export
 */
export const ConfigControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get application configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<ConfigResponse> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigControllerApi - object-oriented interface
 * @export
 * @class ConfigControllerApi
 * @extends {BaseAPI}
 */
export class ConfigControllerApi extends BaseAPI {
    /**
     * 
     * @summary Get application configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateControllerApi - axios parameter creator
 * @export
 */
export const CreateControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute the configuration item creation
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createRequest: CreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('create', 'createRequest', createRequest)
            const localVarPath = `/api/create/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration item creation template
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreateTemplate: async (configurationItemName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemName' is not null or undefined
            assertParamExists('getCreateTemplate', 'configurationItemName', configurationItemName)
            const localVarPath = `/api/create/template/{configurationItemName}`
                .replace(`{${"configurationItemName"}}`, encodeURIComponent(String(configurationItemName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateControllerApi - functional programming interface
 * @export
 */
export const CreateControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute the configuration item creation
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createRequest: CreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get configuration item creation template
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreateTemplate(configurationItemName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreateTemplate(configurationItemName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateControllerApi - factory interface
 * @export
 */
export const CreateControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute the configuration item creation
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createRequest: CreateRequest, options?: any): AxiosPromise<CreateResponse> {
            return localVarFp.create(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get configuration item creation template
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreateTemplate(configurationItemName: string, options?: any): AxiosPromise<CreateRequest> {
            return localVarFp.getCreateTemplate(configurationItemName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateControllerApi - object-oriented interface
 * @export
 * @class CreateControllerApi
 * @extends {BaseAPI}
 */
export class CreateControllerApi extends BaseAPI {
    /**
     * 
     * @summary Execute the configuration item creation
     * @param {CreateRequest} createRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateControllerApi
     */
    public create(createRequest: CreateRequest, options?: AxiosRequestConfig) {
        return CreateControllerApiFp(this.configuration).create(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get configuration item creation template
     * @param {string} configurationItemName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateControllerApi
     */
    public getCreateTemplate(configurationItemName: string, options?: AxiosRequestConfig) {
        return CreateControllerApiFp(this.configuration).getCreateTemplate(configurationItemName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GraphControllerApi - axios parameter creator
 * @export
 */
export const GraphControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GenerateGraphRequest} generateGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (generateGraphRequest: GenerateGraphRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateGraphRequest' is not null or undefined
            assertParamExists('generate', 'generateGraphRequest', generateGraphRequest)
            const localVarPath = `/api/graph/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateGraphRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAvailablePathsRequest} getAvailablePathsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaths: async (getAvailablePathsRequest: GetAvailablePathsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAvailablePathsRequest' is not null or undefined
            assertParamExists('getAvailablePaths', 'getAvailablePathsRequest', getAvailablePathsRequest)
            const localVarPath = `/api/graph/getAvailablePaths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAvailablePathsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphControllerApi - functional programming interface
 * @export
 */
export const GraphControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GenerateGraphRequest} generateGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(generateGraphRequest: GenerateGraphRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateGraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateGraphRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAvailablePathsRequest} getAvailablePathsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailablePaths(getAvailablePathsRequest: GetAvailablePathsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailablePathsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailablePaths(getAvailablePathsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphControllerApi - factory interface
 * @export
 */
export const GraphControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GenerateGraphRequest} generateGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(generateGraphRequest: GenerateGraphRequest, options?: any): AxiosPromise<GenerateGraphResponse> {
            return localVarFp.generate(generateGraphRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAvailablePathsRequest} getAvailablePathsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaths(getAvailablePathsRequest: GetAvailablePathsRequest, options?: any): AxiosPromise<GetAvailablePathsResponse> {
            return localVarFp.getAvailablePaths(getAvailablePathsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphControllerApi - object-oriented interface
 * @export
 * @class GraphControllerApi
 * @extends {BaseAPI}
 */
export class GraphControllerApi extends BaseAPI {
    /**
     * 
     * @param {GenerateGraphRequest} generateGraphRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphControllerApi
     */
    public generate(generateGraphRequest: GenerateGraphRequest, options?: AxiosRequestConfig) {
        return GraphControllerApiFp(this.configuration).generate(generateGraphRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAvailablePathsRequest} getAvailablePathsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphControllerApi
     */
    public getAvailablePaths(getAvailablePathsRequest: GetAvailablePathsRequest, options?: AxiosRequestConfig) {
        return GraphControllerApiFp(this.configuration).getAvailablePaths(getAvailablePathsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ListControllerApi - axios parameter creator
 * @export
 */
export const ListControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List configuration items of the specified type
         * @param {string} configurationItemName 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigurationItems: async (configurationItemName: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemName' is not null or undefined
            assertParamExists('listConfigurationItems', 'configurationItemName', configurationItemName)
            const localVarPath = `/api/list/{configurationItemName}`
                .replace(`{${"configurationItemName"}}`, encodeURIComponent(String(configurationItemName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListControllerApi - functional programming interface
 * @export
 */
export const ListControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * List configuration items of the specified type
         * @param {string} configurationItemName 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConfigurationItems(configurationItemName: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConfigurationItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConfigurationItems(configurationItemName, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListControllerApi - factory interface
 * @export
 */
export const ListControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListControllerApiFp(configuration)
    return {
        /**
         * List configuration items of the specified type
         * @param {string} configurationItemName 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigurationItems(configurationItemName: string, limit?: number, offset?: number, options?: any): AxiosPromise<ListConfigurationItemResponse> {
            return localVarFp.listConfigurationItems(configurationItemName, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListControllerApi - object-oriented interface
 * @export
 * @class ListControllerApi
 * @extends {BaseAPI}
 */
export class ListControllerApi extends BaseAPI {
    /**
     * List configuration items of the specified type
     * @param {string} configurationItemName 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListControllerApi
     */
    public listConfigurationItems(configurationItemName: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ListControllerApiFp(this.configuration).listConfigurationItems(configurationItemName, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataControllerApi - axios parameter creator
 * @export
 */
export const MetadataControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassMetadata: async (configurationItemType: string, properties?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemType' is not null or undefined
            assertParamExists('getClassMetadata', 'configurationItemType', configurationItemType)
            const localVarPath = `/api/metadata/{configurationItemType}`
                .replace(`{${"configurationItemType"}}`, encodeURIComponent(String(configurationItemType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (properties !== undefined) {
                localVarQueryParameter['properties'] = properties;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get class model
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassModel: async (properties?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (properties !== undefined) {
                localVarQueryParameter['properties'] = properties;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataControllerApi - functional programming interface
 * @export
 */
export const MetadataControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClassMetadata(configurationItemType: string, properties?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerializableConfigurationItemDescriptor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClassMetadata(configurationItemType, properties, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get class model
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClassModel(properties?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClassModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClassModel(properties, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataControllerApi - factory interface
 * @export
 */
export const MetadataControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassMetadata(configurationItemType: string, properties?: boolean, options?: any): AxiosPromise<SerializableConfigurationItemDescriptor> {
            return localVarFp.getClassMetadata(configurationItemType, properties, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get class model
         * @param {boolean} [properties] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassModel(properties?: boolean, options?: any): AxiosPromise<GetClassModelResponse> {
            return localVarFp.getClassModel(properties, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataControllerApi - object-oriented interface
 * @export
 * @class MetadataControllerApi
 * @extends {BaseAPI}
 */
export class MetadataControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} configurationItemType 
     * @param {boolean} [properties] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataControllerApi
     */
    public getClassMetadata(configurationItemType: string, properties?: boolean, options?: AxiosRequestConfig) {
        return MetadataControllerApiFp(this.configuration).getClassMetadata(configurationItemType, properties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get class model
     * @param {boolean} [properties] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataControllerApi
     */
    public getClassModel(properties?: boolean, options?: AxiosRequestConfig) {
        return MetadataControllerApiFp(this.configuration).getClassModel(properties, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferenceControllerApi - axios parameter creator
 * @export
 */
export const ReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {string} configurationItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationItem: async (configurationItemType: string, configurationItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemType' is not null or undefined
            assertParamExists('getConfigurationItem', 'configurationItemType', configurationItemType)
            // verify required parameter 'configurationItemId' is not null or undefined
            assertParamExists('getConfigurationItem', 'configurationItemId', configurationItemId)
            const localVarPath = `/api/reference/{configurationItemType}/{configurationItemId}`
                .replace(`{${"configurationItemType"}}`, encodeURIComponent(String(configurationItemType)))
                .replace(`{${"configurationItemId"}}`, encodeURIComponent(String(configurationItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceControllerApi - functional programming interface
 * @export
 */
export const ReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {string} configurationItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationItem(configurationItemType: string, configurationItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationItemReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurationItem(configurationItemType, configurationItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferenceControllerApi - factory interface
 * @export
 */
export const ReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferenceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} configurationItemType 
         * @param {string} configurationItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationItem(configurationItemType: string, configurationItemId: string, options?: any): AxiosPromise<ConfigurationItemReference> {
            return localVarFp.getConfigurationItem(configurationItemType, configurationItemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferenceControllerApi - object-oriented interface
 * @export
 * @class ReferenceControllerApi
 * @extends {BaseAPI}
 */
export class ReferenceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} configurationItemType 
     * @param {string} configurationItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public getConfigurationItem(configurationItemType: string, configurationItemId: string, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).getConfigurationItem(configurationItemType, configurationItemId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchControllerApi - axios parameter creator
 * @export
 */
export const SearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute: async (searchRequest: SearchRequest, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists('execute', 'searchRequest', searchRequest)
            const localVarPath = `/api/search/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTemplate: async (configurationItemName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemName' is not null or undefined
            assertParamExists('getSearchTemplate', 'configurationItemName', configurationItemName)
            const localVarPath = `/api/search/template/{configurationItemName}`
                .replace(`{${"configurationItemName"}}`, encodeURIComponent(String(configurationItemName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchControllerApi - functional programming interface
 * @export
 */
export const SearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async execute(searchRequest: SearchRequest, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerializableTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.execute(searchRequest, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchTemplate(configurationItemName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchTemplate(configurationItemName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchControllerApi - factory interface
 * @export
 */
export const SearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(searchRequest: SearchRequest, limit?: number, offset?: number, options?: any): AxiosPromise<SerializableTable> {
            return localVarFp.execute(searchRequest, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} configurationItemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTemplate(configurationItemName: string, options?: any): AxiosPromise<SearchRequest> {
            return localVarFp.getSearchTemplate(configurationItemName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchControllerApi - object-oriented interface
 * @export
 * @class SearchControllerApi
 * @extends {BaseAPI}
 */
export class SearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {SearchRequest} searchRequest 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public execute(searchRequest: SearchRequest, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).execute(searchRequest, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} configurationItemName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchControllerApi
     */
    public getSearchTemplate(configurationItemName: string, options?: AxiosRequestConfig) {
        return SearchControllerApiFp(this.configuration).getSearchTemplate(configurationItemName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdateControllerApi - axios parameter creator
 * @export
 */
export const UpdateControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfigurationItemReference} configurationItemReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildUpdateTemplate: async (configurationItemReference: ConfigurationItemReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationItemReference' is not null or undefined
            assertParamExists('buildUpdateTemplate', 'configurationItemReference', configurationItemReference)
            const localVarPath = `/api/update/buildUpdateTemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationItemReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (updateRequest: UpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('update', 'updateRequest', updateRequest)
            const localVarPath = `/api/update/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateControllerApi - functional programming interface
 * @export
 */
export const UpdateControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConfigurationItemReference} configurationItemReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildUpdateTemplate(configurationItemReference: ConfigurationItemReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildUpdateTemplate(configurationItemReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(updateRequest: UpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationItemReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateControllerApi - factory interface
 * @export
 */
export const UpdateControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ConfigurationItemReference} configurationItemReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildUpdateTemplate(configurationItemReference: ConfigurationItemReference, options?: any): AxiosPromise<UpdateRequest> {
            return localVarFp.buildUpdateTemplate(configurationItemReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateRequest: UpdateRequest, options?: any): AxiosPromise<ConfigurationItemReference> {
            return localVarFp.update(updateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateControllerApi - object-oriented interface
 * @export
 * @class UpdateControllerApi
 * @extends {BaseAPI}
 */
export class UpdateControllerApi extends BaseAPI {
    /**
     * 
     * @param {ConfigurationItemReference} configurationItemReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateControllerApi
     */
    public buildUpdateTemplate(configurationItemReference: ConfigurationItemReference, options?: AxiosRequestConfig) {
        return UpdateControllerApiFp(this.configuration).buildUpdateTemplate(configurationItemReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateControllerApi
     */
    public update(updateRequest: UpdateRequest, options?: AxiosRequestConfig) {
        return UpdateControllerApiFp(this.configuration).update(updateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewControllerApi - axios parameter creator
 * @export
 */
export const ViewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BindViewRequest} bindViewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bind: async (bindViewRequest: BindViewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindViewRequest' is not null or undefined
            assertParamExists('bind', 'bindViewRequest', bindViewRequest)
            const localVarPath = `/api/view/bind`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bindViewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAvailableViewsRequest} getAvailableViewsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableViews: async (getAvailableViewsRequest: GetAvailableViewsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAvailableViewsRequest' is not null or undefined
            assertParamExists('getAvailableViews', 'getAvailableViewsRequest', getAvailableViewsRequest)
            const localVarPath = `/api/view/getAvailable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAvailableViewsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewControllerApi - functional programming interface
 * @export
 */
export const ViewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BindViewRequest} bindViewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bind(bindViewRequest: BindViewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BindViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bind(bindViewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAvailableViewsRequest} getAvailableViewsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableViews(getAvailableViewsRequest: GetAvailableViewsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailableViewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableViews(getAvailableViewsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewControllerApi - factory interface
 * @export
 */
export const ViewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {BindViewRequest} bindViewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bind(bindViewRequest: BindViewRequest, options?: any): AxiosPromise<BindViewResponse> {
            return localVarFp.bind(bindViewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAvailableViewsRequest} getAvailableViewsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableViews(getAvailableViewsRequest: GetAvailableViewsRequest, options?: any): AxiosPromise<GetAvailableViewsResponse> {
            return localVarFp.getAvailableViews(getAvailableViewsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewControllerApi - object-oriented interface
 * @export
 * @class ViewControllerApi
 * @extends {BaseAPI}
 */
export class ViewControllerApi extends BaseAPI {
    /**
     * 
     * @param {BindViewRequest} bindViewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewControllerApi
     */
    public bind(bindViewRequest: BindViewRequest, options?: AxiosRequestConfig) {
        return ViewControllerApiFp(this.configuration).bind(bindViewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAvailableViewsRequest} getAvailableViewsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewControllerApi
     */
    public getAvailableViews(getAvailableViewsRequest: GetAvailableViewsRequest, options?: AxiosRequestConfig) {
        return ViewControllerApiFp(this.configuration).getAvailableViews(getAvailableViewsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


